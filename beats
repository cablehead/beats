#!/usr/bin/env python

"""
Usage:
    beats playlists
    beats playlists create <name> [--private]
    beats playlists delete <id>
    beats playlists show <id>
    beats playlists update <id> delete <track_id>
    beats tracks show <id>
    beats albums show <id>
    beats serve
"""


import shelve
import json
import sys
import os

import requests
import docopt


# TODO: remove
import logging
logging.basicConfig()


__version__ = '0.1'


"""
# Auth

uri = 'https://partner.api.beatsmusic.com/oauth2/token/password'

params = {
    'grant_type': 'password',
    'client_id': app_key,
    'client_secret': app_secret,
    'username': '...',
    'password': '...', }

response = requests.post(uri, params=params)
print response
print response.text
"""


def truncate(s, l):
    if len(s) > l:
        s = s[:l-3]+'...'
    return s


def to_duration(s):
    ret = ''
    h = s / (60*60)
    s = s % (60*60)
    m =  s / 60
    s =  s % 60
    if h:
        ret += '%dh' % h
    if m:
        ret += '%dm' % m
    ret += '%ds' % s
    return ret


def test_to_duration():
    assert to_duration(30) == '30s'
    assert to_duration(80) == '1m20s'
    assert to_duration(7520) == '2h5m20s'


def cached(f):
    def wrapped(beats, id):
        if id not in beats.config:
            beats.config[id] = f(beats, id)
        return beats.config[id]
    return wrapped


class Beats(object):
    URI = 'https://partner.api.beatsmusic.com/v1/api/'
    client_id = 'fxkrj7vemnnxva8jhtqb9wt8'

    def __init__(self, token):
        self.config = config
        self.token = config['token']

    def public(self, method, path, params=None):
        if params is None:
            params = {}
        params['client_id'] = Beats.client_id
        response = requests.request(
            method,
            Beats.URI+path,
            params=params)
        return self.response(response)

    def private(self, method, path, params=None):
        response = requests.request(
            method,
            Beats.URI+path,
            params=params,
            headers={'Authorization': 'Bearer %s' % self.token})
        return self.response(response)

    def response(self, response):
        if response.status_code == 200:
            return json.loads(response.text)
        print response
        print response.text

    def activities(self):
        return self.public('GET', 'activities')

    def albums(self, album_id):
        return self.public('GET', 'albums/%s' % album_id)

    def albums_image(self, album_id):
        return Beats.URI + \
            ('albums/%s/images/default' % album_id) + \
            ('?client_id=%s' % Beats.client_id)

    def me(self):
        return self.private('GET', 'me')['result']

    def playlists_user(self, user_id):
        return self.private('GET', 'users/%s/playlists' % user_id)

    def playlists(self, playlist_id):
        return self.private('GET', 'playlists/%s' % playlist_id)

    def playlists_create(self, name, description=None, access=None):
        # access defaults to 'public'
        params = {'name': name}
        if description:
            params['description'] = description
        if access:
            assert access in ('public', 'private')
            params['access'] = access
        return self.private('POST', 'playlists', params=params)

    def playlists_delete(self, playlist_id):
        return self.private('DELETE', 'playlists/%s' % playlist_id)

    def playlists_image(self, playlist_id):
        return Beats.URI + \
            ('playlists/%s/images/default' % playlist_id) + \
            ('?client_id=%s' % Beats.client_id)

    def playlists_update(self, playlist_id, track_ids):
        params = {
            'playlist_id': playlist_id,
            'track_ids': track_ids, }
        return self.private(
            'PUT', 'playlists/%s/tracks' % playlist_id, params=params)

    @cached
    def tracks(self, track_id):
        return self.public('GET', 'tracks/%s' % track_id)

    def tracks_audio(self, track_id):
        return self.private(
            'GET', 'tracks/%s/audio' % track_id, params={'acquire': 1})


def main(config, argv):
    beats = Beats(config)

    if argv['playlists']:
        if argv['update']:
            if argv['delete']:
                id = argv['<id>']
                track_id = argv['<track_id>']
                response = beats.playlists(id)
                current = [x['id'] for x in response['data']['refs']['tracks']]

                if track_id not in current:
                    print '%s not in playlist' % track_id
                    return 1

                current.remove(track_id)
                beats.playlists_update(id, current)
                return
            raise

        if argv['create']:
            beats.playlists_create(
                argv['<name>'],
                description=None,
                access=argv['--private'] and 'private' or 'public')
            return

        if argv['delete']:
            beats.playlists_delete(argv['<id>'])
            return

        if argv['show']:
            response = beats.playlists(argv['<id>'])
            item = response['data']
            print beats.playlists_image(argv['<id>'])
            print '%-22s%s (%s:%s)' % (
                item['id'],
                item['name'],
                len(item['refs']['tracks']),
                to_duration(item['duration']))
            for track in item['refs']['tracks']:
                extra = beats.tracks(track['id'])['data']
                print '  %-12s %-30s %-30s %s' % (
                    track['id'],
                    truncate(extra['artist_display_name'], 30),
                    truncate(track['display'], 30),
                    to_duration(extra['duration']))
            return

        response = beats.playlists_user(config['user_id'])
        for item in reversed(
                sorted(response['data'], key=lambda x: x['updated_at'])):
            print '%-22s%s (%s:%s)' % (
                item['id'],
                item['name'],
                len(item['refs']['tracks']),
                to_duration(item['duration']))

    if argv['tracks']:
        if argv['show']:

            id = argv['<id>']
            print beats.tracks(id)

            audio = beats.tracks_audio(id)

            import vanilla
            h = vanilla.Hub()
            conn = h.tcp.connect(host='localhost', port=10080)
            conn.send(json.dumps({
                'id': id,
                'host': audio['data']['location'],
                'asset': audio['data']['resource'], }))
            conn.close()

    if argv['albums']:
        if argv['show']:
            print beats.albums_image(argv['<id>'])

    if argv['serve']:
        import vanilla
        h = vanilla.Hub()

        b = h.bean(host='localhost', port=8080)
        b.static('/', 'serve/index.html')
        b.static('/swf', 'serve/swf')
        b.static('/script', 'serve/script')

        updates = h.broadcast()

        serve = h.tcp.listen(host='localhost', port=10080)
        @serve.consume
        def _(conn):
            updates.send(conn.recv())
            conn.close()

        @b.websocket('/')
        def _(ws):
            u = updates.subscribe()
            for i in u:
                ws.send(i)

        print 'listening on on http://localhost:8080'
        h.stop_on_term()


if __name__ == '__main__':
    config = shelve.open(os.path.expanduser('~/.beats'), 'c')
    argv = docopt.docopt(__doc__, version=__version__)
    try:
        sys.exit(main(config, argv))
    finally:
        config.close()
